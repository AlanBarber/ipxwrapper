/* IPXWrapper - Unit tests
 * Copyright (C) 2014 Daniel Collins <solemnwarning@solemnwarning.net>
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published by
 * the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc., 51
 * Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
*/

#ifndef IPXWRAPPER_TEST_H
#define IPXWRAPPER_TEST_H

#include <stdio.h>
#include <stdlib.h>

#define FAIL(fmt, ...) \
{ \
	fprintf(stderr, "Failure at %s:%d: " fmt "\n", __FILE__, __LINE__, ## __VA_ARGS__); \
	exit(1); \
}

#define EXPECT_NO_PACKETS(sock) \
{ \
	char recv_buf[1024]; \
	int r = recv(sock2, recv_buf, sizeof(recv_buf), 0); \
	if(r != -1) \
	{ \
		FAIL("Received %d byte packet", r); \
	} \
	if(WSAGetLastError() != WSAEWOULDBLOCK) \
	{ \
		FAIL("Received no packets, but WSAGetLastError() is %d", WSAGetLastError()); \
	} \
}

#define EXPECT_PACKET(sock, data) \
{ \
	char buf[1024]; \
	int r = recv(sock, buf, sizeof(buf), 0); \
	if(r == -1) \
	{ \
		FAIL("Received no packets, WSAGetLastError = %d", WSAGetLastError()); \
	} \
	else if(r != sizeof(data)) \
	{ \
		FAIL("Received %d byte packet (expected %d)", r, (int)(sizeof(data))); \
	} \
	if(memcmp(buf, data, sizeof(data)) != 0)\
	{ \
		FAIL("Received packet with wrong payload"); \
	} \
}

#define EXPECT_PACKET_FROM(sock, data, src) \
{ \
	char buf[1024]; \
	struct sockaddr_ipx addrbuf; \
	int addrlen = sizeof(addrbuf); \
	int r = recvfrom(sock, buf, sizeof(buf), 0, (struct sockaddr*)(&addrbuf), &addrlen); \
	if(r == -1) \
	{ \
		FAIL("Received no packets, WSAGetLastError = %d", WSAGetLastError()); \
	} \
	else if(r != sizeof(data)) \
	{ \
		FAIL("Received %d byte packet (expected %d)", r, (int)(sizeof(data))); \
	} \
	if(memcmp(buf, data, sizeof(data)) != 0)\
	{ \
		FAIL("Received packet with wrong payload"); \
	} \
	if(addrlen != sizeof(struct sockaddr_ipx)) \
	{ \
		FAIL("Received packet, but addrlen is %d bytes (expected %d)", addrlen, (int)(sizeof(struct sockaddr_ipx))); \
	} \
	if(memcmp(&addrbuf, &src, sizeof(struct sockaddr_ipx)) != 0) \
	{ \
		FAIL("Received packet, but the source address is wrong"); \
	} \
}

static const char test_data_1[] = {
	0x57, 0x65, 0x27, 0x72, 0x65, 0x20, 0x4b, 0x6e, 0x69, 0x67, 0x68, 0x74,
	0x73, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x52, 0x6f, 0x75,
	0x6e, 0x64, 0x20, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x2e,
	
	0x57, 0x65, 0x20, 0x64, 0x61, 0x6e, 0x63, 0x65, 0x20, 0x77, 0x68, 0x65,
	0x6e, 0x65, 0x27, 0x65, 0x72, 0x20, 0x77, 0x65, 0x27, 0x72, 0x65, 0x20,
	0x61, 0x62, 0x6c, 0x65, 0x2e,
	
	0x57, 0x65, 0x20, 0x64, 0x6f, 0x20, 0x72, 0x6f, 0x75, 0x74, 0x69, 0x6e,
	0x65, 0x73, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x63, 0x68, 0x6f, 0x72, 0x75,
	0x73, 0x20, 0x73, 0x63, 0x65, 0x6e, 0x65, 0x73,
	
	0x57, 0x69, 0x74, 0x68, 0x20, 0x66, 0x6f, 0x6f, 0x74, 0x77, 0x6f, 0x72,
	0x6b, 0x20, 0x69, 0x6d, 0x70, 0x65, 0x63, 0x63, 0x61, 0x62, 0x6c, 0x65,
	0x2e,
	
	0x57, 0x65, 0x20, 0x64, 0x69, 0x6e, 0x65, 0x20, 0x77, 0x65, 0x6c, 0x6c,
	0x20, 0x68, 0x65, 0x72, 0x65, 0x20, 0x69, 0x6e, 0x20, 0x43, 0x61, 0x6d,
	0x65, 0x6c, 0x6f, 0x74, 0x2e,
	
	0x57, 0x65, 0x20, 0x65, 0x61, 0x74, 0x20, 0x68, 0x61, 0x6d, 0x20, 0x61,
	0x6e, 0x64, 0x20, 0x6a, 0x61, 0x6d, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x73,
	0x70, 0x61, 0x6d, 0x20, 0x61, 0x20, 0x6c, 0x6f, 0x74, 0x2e,
	
	0x57, 0x65, 0x27, 0x72, 0x65, 0x20, 0x4b, 0x6e, 0x69, 0x67, 0x68, 0x74,
	0x73, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x52, 0x6f, 0x75,
	0x6e, 0x64, 0x20, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x2e,
	
	0x4f, 0x75, 0x72, 0x20, 0x73, 0x68, 0x6f, 0x77, 0x73, 0x20, 0x61, 0x72,
	0x65, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x69, 0x64, 0x61, 0x62, 0x6c, 0x65,
	0x2c,
	
	0x42, 0x75, 0x74, 0x20, 0x6d, 0x61, 0x6e, 0x79, 0x20, 0x74, 0x69, 0x6d,
	0x65, 0x73, 0x20, 0x77, 0x65, 0x27, 0x72, 0x65, 0x20, 0x67, 0x69, 0x76,
	0x65, 0x6e, 0x20, 0x72, 0x68, 0x79, 0x6d, 0x65, 0x73,
	
	0x54, 0x68, 0x61, 0x74, 0x20, 0x61, 0x72, 0x65, 0x20, 0x71, 0x75, 0x69,
	0x74, 0x65, 0x20, 0x75, 0x6e, 0x73, 0x69, 0x6e, 0x67, 0x61, 0x62, 0x6c,
	0x65, 0x2e,
	
	0x57, 0x65, 0x27, 0x72, 0x65, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x20,
	0x6d, 0x61, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x43, 0x61, 0x6d, 0x65, 0x6c,
	0x6f, 0x74, 0x2e,
	
	0x57, 0x65, 0x20, 0x73, 0x69, 0x6e, 0x67, 0x20, 0x66, 0x72, 0x6f, 0x6d,
	0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x69, 0x61, 0x70, 0x68, 0x72, 0x61,
	0x67, 0x6d, 0x20, 0x61, 0x20, 0x6c, 0x6f, 0x74, 0x2e
};

static const char test_data_2[] = {
	0x49, 0x6e, 0x20, 0x77, 0x61, 0x72, 0x20, 0x77, 0x65, 0x27, 0x72, 0x65,
	0x20, 0x74, 0x6f, 0x75, 0x67, 0x68, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x61,
	0x62, 0x6c, 0x65, 0x2c,
	
	0x51, 0x75, 0x69, 0x74, 0x65, 0x20, 0x69, 0x6e, 0x64, 0x65, 0x66, 0x61,
	0x74, 0x69, 0x67, 0x61, 0x62, 0x6c, 0x65, 0x2e,
	
	0x42, 0x65, 0x74, 0x77, 0x65, 0x65, 0x6e, 0x20, 0x6f, 0x75, 0x72, 0x20,
	0x71, 0x75, 0x65, 0x73, 0x74, 0x73, 0x20, 0x77, 0x65, 0x20, 0x73, 0x65,
	0x71, 0x75, 0x69, 0x6e, 0x20, 0x76, 0x65, 0x73, 0x74, 0x73, 0x20, 0x61,
	0x6e, 0x64, 0x20, 0x69, 0x6d, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0x61,
	0x74, 0x65, 0x20, 0x43, 0x6c, 0x61, 0x72, 0x6b, 0x20, 0x47, 0x61, 0x62,
	0x6c, 0x65, 0x2e,
	
	0x49, 0x74, 0x27, 0x73, 0x20, 0x61, 0x20, 0x62, 0x75, 0x73, 0x79, 0x20,
	0x6c, 0x69, 0x66, 0x65, 0x20, 0x69, 0x6e, 0x20, 0x43, 0x61, 0x6d, 0x65,
	0x6c, 0x6f, 0x74, 0x2e,
	
	0x49, 0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x70, 0x75,
	0x73, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x61, 0x6d, 0x20,
	0x61, 0x20, 0x6c, 0x6f, 0x74, 0x2e
};

#endif /* !IPXWRAPPER_TEST_H */
